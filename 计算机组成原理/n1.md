## 1.2程序的表象之下

#### 简单的软硬件层次化结构

+ 隐藏低层层次的实现细节，简化各层次上用户的使用。

+ ”抽象“ -> 每一层都为上一层隐藏了自己的技术细节。

  <img src="C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210202183602532.png" alt="image-20210202183602532" style="zoom:45%;" />

+ 系统软件：提供公共服务程序，

  + 汇编器：将汇编转化为二进制代码
  + 编译器：将高级语言翻译为汇编代码

#### 计算机的层次结构

<img src="C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210202183913525.png" alt="image-20210202183913525" style="zoom:67%;" />

#### 从程序到电子信号

+ 红框内就是计算机内部的工作过程：逐条加载到内存中的二进制机器指令流的过程
+ 一条指令的执行过程可简单的分为两个操作阶段
  + 取指阶段：CPU从内存中读取指令，程序计数器保存要取出的下一条指令的地址，除非遇到跳转指令等情况，否则PC一般都是在每次取指后加上一个当前指令的字节数。
  + 执行阶段，对取出的指令先译码，解释指令的功能，然后执行译码好的指令，这期间可能会读写存储器或端口来获取操作数或存放结果。
+ 程序的执行过程就是周期性和重复性的进行取指令和执行指令两个操作。

<img src="C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210202191419935.png" alt="image-20210202191419935" style="zoom:67%;" />

​	



## 1.3 打开计算机的机箱

#### :star2:存储程序原理

+ 将实现设计好，用以描述计算机解题过程的程序如同数据一样，采用二进制形式存储在机器中，计算机在工作时自动高速地从机器中逐条取出指令加以执行。



#### 冯诺依曼计算机框架

![image-20210202195129388](C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210202195129388.png)



#### 功能部件--CPU

+ 功能：执行程序
+ 组成：control unit + data path
  + control unit（控制单元）：对指令译码，产生控制信号
  + data path（数据通路）：完成指令的执行
    + 核心：ALU + Register
      + ALU：用来执行算数逻辑运算
      + 寄存器：用来存储临时的数据或控制信息

#### 功能部件--存储器

+ 功能：存储程序和数据
+ 组成（层次化结构）
  + 内存：cache+ memory
    + cache：存放最近使用的数据和指令
    + memory：存放被启动的程序中的部分数据和指令
  + 外存：磁盘，固态盘，光盘
    + 磁盘/固态盘：存放系统中所有软件和文档
    + 光盘/磁带：脱机存档



#### 功能部件3--输入/输出

+ 功能：各种信息的输入输出
+ 组成：I/O controller + I/O device
  + I/O controller：控制外设工作，完成主机和外设之间的通信
  + I/O device：输入输出信息 

+ 总线用于各功能部件之间的连接，控制器可以区分从存储单元中取出的是数据还是指令。



## 1.4 计算机性能评价

#### 衡量计算机性能的基本指标

+ 响应时间response time

  + 执行时间 execution time，等待时间 latency

+ 吞吐率throughput

  + 带宽bandwidth

+ 指令执行速度MIPS , MFLOPS

+ 功耗power

+ 制造成本 manufacturing cost

  

#### 计算机有两种不同的性能

+ time to do the task
  + 响应时间：完成单个任务所需的总时间
  + 执行时间
  + 等待时间或时延
+ task per day，hour，sec..
  + 吞吐率：单位时间内完成的任务总量
  + 带宽

> 1. 更换处理器为更好型号：能够在减少相应时间的同时增加系统的吞吐率
> 2. 增加多处理器分别处理独立任务：能增加吞吐率，但对任务的响应时间没有影响，当系统需要处理的任务过多，有很多待处理的任务正在排队时，是能够有效的减少这些任务的响应时间



#### 计算机性能计算

+ 性能 = 响应时间（执行时间）的倒数

+ 计算机X是计算机Y的n倍快 = 
  $$
  \frac{性能x}{性能y} = \frac{执行时间y}{执行时间x} = n
  $$
  

> 相对性能计算
>
> 1. 如果计算机A运行一个程序需要10秒，B运算要15秒，问A的速度是B的几倍？
>    $$
>    \frac{B执行时间}{A执行时间}　＝　\frac{15}{10}　＝　1.5
>    $$
>    

#### 性能度量

+ 比较计算机性能时，可以用响应时间（执行时间）来衡量
  + 完成同样工作量所需时间最短的那台计算机性能最好
  + 处理器时间往往被多个程序共享使用，因此用户感觉到的程序执行时间并不是仅仅是程序真正的执行时间
+ 系统响应时间（用户感受到的）
  + CPU执行时间：CPU真正花费在程序执行上的时间
    + 用户CPU时间：用来运行代码的时间
    + 系统CPU时间：为执行用户程序而需运行一些操作系统代码的时间
    + 系统CPU时间包括用户CPU时间
  + 其他时间：等待I/O操作完成或CPU花在其他用户程序的时间
+ 计算机系统性能 != CPU性能
  + 系统性能：表示系统响应时间
  + CPU性能：表示CPU真正用于用户程序执行上的时间

#### CPU执行时间的计算

+ 评价CPU性能最重要的指标 ： CPU执行时间
  + 一个程序的CPU执行时间=执行一个程序需要的基本时间单元的数量*基本时间单元
  + 时钟周期clock cycle
    + 所有计算机都有一个固定频率的硬件时钟，决定各种硬件事件发生和执行的时间和顺序。
    + 硬件时钟所产生的离散时间间隔称为时钟周期
  + 时钟频率clock rate
    + 时钟周期的倒数

> 时钟周期为250ps，对应的时钟频率为多少？
>
> ​	A：时钟频率 = 1/时钟周期 = 1/250ps = 4GHZ
>
> ms(毫秒),μs(微秒),ns(纳秒),ps(皮秒)

$$
一个程序的CPU执行时间 = 一个程序的CPU时钟周期数*时钟周期时间
				   = \frac{一个程序的CPU时钟周期数}{时钟频率} \\
一个程序的CPU时钟周期数 = 程序的指令数*每条指令的平均时钟周期数(CPI) \\
CPU time = \frac{seconds}{program} = \frac{instructions}{program}*\frac{clock cycles}{instruct}*\frac{seconds}{clock cycle}\\
一个程序的CPU时间=指令数/程序*CPI*时钟周期时间
$$

![image-20210203084000688](C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210203084000688.png)

![image-20210203084025349](C:\Users\qidai\Documents\GitHub\note\计算机组成原理\n1.assets\image-20210203084025349.png)